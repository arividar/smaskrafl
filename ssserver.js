// Generated by CoffeeScript 2.7.0
(function() {
  // Requires
  var Game, GameManager, app, express, extend, forwardInvitation, gameManager, getWords, handleInviteResponse, idClientMap, io, logClientIdMap, newGame, pendingInvitations, port, removeFromGame, resetTimer, sendGameOver, server, socket, startTimer, typeAndContent, welcomePlayers;

  express = require('express');

  io = require('socket.io');

  ({Game} = require('./Game'));

  ({GameManager} = require('./GameManager'));

  console.log('***** dirname: ' + __dirname + '/client');

  // Create server
  app = express();

  app.use(express.static(__dirname + '/client'));

  app.use(express.urlencoded({
    extended: true
  }));

  // Process client requests
  app.get("/", function(req, res) {
    return res.sendFile(__dirname + "/client/index.html");
  });

  app.post("/send", function(req, res) {
    return res.redirect(`/game.html\?player=${req.body.userName}`);
  });

  // Start server
  port = process.env.PORT || 3000;

  console.log('Listening to port ' + port);

  server = app.listen(port);

  console.log(`Browse to http://localhost:${port} to play`);

  // Game server
  gameManager = new GameManager();

  idClientMap = {};

  pendingInvitations = [];

  // Bind socket to HTTP server
  socket = io(server);

  // Handle client messages
  socket.on('connection', (client) => {
    client.on('login', (loginInfo) => {
      var c, id, key, p, val;
      if (gameManager.login(client.id, loginInfo.playername)) {
        idClientMap[client.id] = client;
        console.log(`************** login - climap=${idClientMap}`);
        for (id in idClientMap) {
          c = idClientMap[id];
          console.log(`************** login - climapid - id=${id}, c.id=${c.id}, len=${((function() {
            var results;
            results = [];
            for (key in idClientMap) {
              val = idClientMap[key];
              results.push(val);
            }
            return results;
          })()).length}`);
          if (id !== client.id) {
            c.emit("newPlayer", JSON.stringify(loginInfo.playername));
          }
        }
        logClientIdMap();
        return client.emit("playerList", JSON.stringify(((function() {
          var j, len, ref, results;
          ref = gameManager.players;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            p = ref[j];
            results.push(p.name);
          }
          return results;
        })()).join(',')));
      } else {
        return client.emit("loginFail");
      }
    });
    //TODO: Respond and handle failed loginxxx
    client.on('newGame', (thePlayers) => {
      var c, id, key, p1, p2, val;
      console.log(`************** ssServer got newGame from client ${client.id}:${thePlayers}`);
      ({p1, p2} = JSON.parse(thePlayers));
      console.log(`************** on.newgame p1=${p1}, p2=${p2}`);
      console.log(`************* on.newGame idclimap.len=${((function() {
        var results;
        results = [];
        for (key in idClientMap) {
          val = idClientMap[key];
          results.push(val);
        }
        return results;
      })()).length}`);
      logClientIdMap();
      for (id in idClientMap) {
        c = idClientMap[id];
        console.log(`************** on newgame - climapid - c.id=${c.id}, id=${id}`);
      }
      return newGame(client, p1, p2);
    });
    client.on('invite', (targetPlayer) => {
      var invitee, inviter;
      console.log(`************** ssServer got invite from client ${client.id} to ${targetPlayer}`);
      inviter = gameManager.getPlayerById(client.id);
      invitee = gameManager.getPlayerByName(targetPlayer);
      if ((invitee != null) && (inviter != null)) {
        return forwardInvitation(inviter, invitee);
      } else {
        return console.log("**************** ERROR: Missing inviter or invitee");
      }
    });
    client.on('inviteResponse', (response) => {
      var invitee;
      console.log(`************** ssServer got inviteResponse from client ${client.id}: ${response}`);
      invitee = gameManager.getPlayerById(client.id);
      if (invitee != null) {
        return handleInviteResponse(invitee.name, response);
      } else {
        return console.log("**************** ERROR: Missing invitee");
      }
    });
    client.on('move', (moveData) => {
      var game, j, len, moveScore, newWords, player, ref, result, swapCoordinates;
      console.log(`************** ssServer got move from client ${client.id}: ${moveData}`);
      game = gameManager.getGameByPlayerId(client);
      if (game == null) {
        console.log(`************** ERROR: Player ${client.id} tried to move but is not in any game`);
        return;
      }
      if (client.id !== game.currPlayer.id) { //no cheating
        return;
      }
      if (game.isGameOver()) {
        clearInterval(game.interval);
        return sendGameOver(game);
      } else {
        swapCoordinates = JSON.parse(moveData);
        ({moveScore, newWords} = game.currPlayer.makeMove(swapCoordinates));
        result = {
          swapCoordinates,
          moveScore,
          player: game.currPlayer,
          newWords: getWords(newWords)
        };
        ref = game.players;
        // only send results to players, reset timer since move has been made
        for (j = 0, len = ref.length; j < len; j++) {
          player = ref[j];
          if (player.id && idClientMap[player.id]) {
            idClientMap[player.id].emit("moveResult", JSON.stringify(result));
          }
        }
        game.endTurn();
        return resetTimer(game.currPlayer, game.otherPlayer);
      }
    });
    return client.on('disconnect', () => {
      var c, id, p;
      // removeFromGame client
      console.log("***** disconnect");
      p = gameManager.getPlayerById(client.id);
      if (p) {
        for (id in idClientMap) {
          c = idClientMap[id];
          if (id !== client.id) {
            c.emit("removePlayer", JSON.stringify(p.name));
          }
        }
      }
      gameManager.logout(client.id);
      delete idClientMap[client.id];
      return logClientIdMap();
    });
  });

  logClientIdMap = function() {
    var c, id, key, results, val;
    console.log(`************** logclimapid - LEN=${((function() {
      var results;
      results = [];
      for (key in idClientMap) {
        val = idClientMap[key];
        results.push(val);
      }
      return results;
    })()).length}`);
    results = [];
    for (id in idClientMap) {
      c = idClientMap[id];
      results.push(console.log(`************** logclimapid - id=${id}, c.id=${c.id}, len=${((function() {
        var results1;
        results1 = [];
        for (key in idClientMap) {
          val = idClientMap[key];
          results1.push(val);
        }
        return results1;
      })()).length}`));
    }
    return results;
  };

  newGame = function(client, username, opponent) {
    var c, game, i, key, val;
    console.log(`************** newGame - player1=${username}, player2=${opponent}`);
    console.log(`************** newGame -  idclimap.len=${((function() {
      var results;
      results = [];
      for (key in idClientMap) {
        val = idClientMap[key];
        results.push(val);
      }
      return results;
    })()).length}`);
    for (i in idClientMap) {
      c = idClientMap[i];
      console.log(`*******newGame - ${client.id} sama og ${c.id}?`);
      if (c.id === client.id) {
        console.log(`********newGAme - found client: ${client.id}`);
      }
    }
    // TBD: hér þarf að breyta til að gangsetja leikinn!!!
    game = gameManager.getGameByPlayerName(opponent);
    if (game == null) {
      console.log("**** newGame1: getting another game");
      game = gameManager.getNewGame();
    }
    console.log(`**** newGame2: the game is: ${game.wasPlayed}`);
    game.addPlayer(client.id, username);
    if (game.isFull()) {
      return welcomePlayers(game);
    }
  };

  removeFromGame = function(client) {
    var game, j, len, player, ref;
    //remove player from game
    game = gameManager.getGameByPlayerId(client);
    game.removePlayer(client.id);
    // remove timer and interval when player disconects and notify remaining player
    clearTimeout(game.timer);
    clearInterval(game.interval);
    ref = game.players;
    for (j = 0, len = ref.length; j < len; j++) {
      player = ref[j];
      if (player.id && idClientMap[player.id]) {
        idClientMap[player.id].emit("opponentQuit", "blank");
      }
    }
    // two players in games where opponent quit can be connected automatically
    return gameManager.connectOrphanedPlayers(welcomePlayers);
  };

  // player loses turn if they take too long
  startTimer = function(currPlayer, otherPlayer) {
    var game, j, len, player, ref;
    game = gameManager.getGameByPlayerId(currPlayer);
    // interval ticker for each second - fire before timer for safety's sake
    game.interval = setInterval(function() {
      var j, len, player, ref, results;
      if (game.isGameOver()) {
        clearInterval(game.interval);
        return sendGameOver(game);
      } else {
        ref = game.players;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          player = ref[j];
          if (player.id && idClientMap[player.id]) {
            results.push(idClientMap[player.id].emit("tick", JSON.stringify('tock')));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    }, 1000);
    ref = game.players;
    // fire off first tick
    for (j = 0, len = ref.length; j < len; j++) {
      player = ref[j];
      if (player.id && idClientMap[player.id]) {
        idClientMap[player.id].emit("tick", JSON.stringify('tick'));
      }
    }
    // timer for turn
    return game.timer = setTimeout(function() {
      currPlayer.moveCount++;
      if (game.isGameOver()) {
        return sendGameOver;
      } else {
        resetTimer(otherPlayer, currPlayer);
        if (currPlayer.id && idClientMap[currPlayer.id]) {
          idClientMap[currPlayer.id].emit("timeIsUp", JSON.stringify(currPlayer));
        }
        if (otherPlayer.id && idClientMap[otherPlayer.id]) {
          idClientMap[otherPlayer.id].emit("yourTurnNow", JSON.stringify(currPlayer));
        }
        game.endTurn();
        return resetTimer(otherPlayer, currPlayer);
      }
    }, Game.TURN_TIME);
  };

  resetTimer = function(currPlayer, otherPlayer) {
    var game;
    game = gameManager.getGameByPlayerId(currPlayer);
    clearTimeout(game.timer);
    clearInterval(game.interval);
    return startTimer(currPlayer, otherPlayer);
  };

  sendGameOver = function(theGame) {
    var info, j, len, player, playerInfo, ref, results;
    info = {
      winner: theGame.winner()
    };
    ref = theGame.players;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      player = ref[j];
      if (player.id && idClientMap[player.id]) {
        playerInfo = extend({}, info, {
          yourNum: player.num
        });
        results.push(idClientMap[player.id].emit("gameOver", JSON.stringify(playerInfo)));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  welcomePlayers = function(game) {
    var c, i, info, j, len, player, playerInfo, ref;
    console.log(`******** welcomePlayers: currPlayer.num=${game.currPlayer.num}`);
    console.log(`******** welcomePlayers: game.player1.id=${game.player1.id}`);
    console.log(`******** welcomePlayers: game.player1.name=${game.player1.name}`);
    console.log(`******** welcomePlayers: game.player1.num=${game.player1.num}`);
    console.log(`******** welcomePlayers: game.player2.id=${game.player2.id}`);
    console.log(`******** welcomePlayers: game.player2.name=${game.player2.name}`);
    console.log(`******** welcomePlayers: game.player2.num=${game.player2.num}`);
    for (i in idClientMap) {
      c = idClientMap[i];
      console.log(`*** welcome iclimap, i=${i}, c.id=${c.id}`);
    }
    info = {
      players: game.players,
      tiles: game.grid.tiles,
      currPlayerNum: game.currPlayer.num,
      newWords: getWords(game.dictionary.usedWords),
      turnTime: Game.TURN_TIME / 1000
    };
    ref = game.players;
    for (j = 0, len = ref.length; j < len; j++) {
      player = ref[j];
      if (player.id && idClientMap[player.id]) {
        playerInfo = extend({}, info, {
          yourNum: player.num
        });
        idClientMap[player.id].emit("welcome", JSON.stringify(playerInfo));
      }
    }
    // reset things just to be safe - could be an old game getting recycled
    return resetTimer(game.currPlayer, game.otherPlayer);
  };

  
  // handleMessage function removed - replaced with individual event listeners above

  // gather used words and defs - only send new ones
  getWords = function(newWords) {
    var defs, j, len, word, wordsHtml;
    wordsHtml = [];
    defs = {};
    for (j = 0, len = newWords.length; j < len; j++) {
      word = newWords[j];
      wordsHtml.push(`<strong>${word}</strong>`);
      defs[word] = gameManager.words[word];
    }
    return {
      wordsHtml: wordsHtml.join(", "),
      defs
    };
  };

  typeAndContent = function(message) {
    var content, ignore, type;
    console.log(`*********** The message is: ${message}`);
    [ignore, type, content] = message.match(/(.*?):(.*)/);
    return {type, content};
  };

  // adds props of arbitrary objs (others) to a
  extend = function(a, ...others) {
    var j, key, len, o, val;
    for (j = 0, len = others.length; j < len; j++) {
      o = others[j];
      for (key in o) {
        val = o[key];
        a[key] = val;
      }
    }
    return a;
  };

  forwardInvitation = function(from, to) {
    var i, j, len;
    // Check if clients are still connected
    if (idClientMap[from.id] == null) {
      console.log(`**** ERROR: Inviter ${from.name} is no longer connected`);
      return false;
    }
    if (idClientMap[to.id] == null) {
      console.log(`**** ERROR: Invitee ${to.name} is no longer connected`);
      return false;
    }
    for (j = 0, len = pendingInvitations.length; j < len; j++) {
      i = pendingInvitations[j];
      if (from.name === i.from || from.name === i.to || to.name === i.from || to.name === i.to) {
        // TODO: Invitation exists and should not be forwarded
        idClientMap[from.id].emit("inviteResponse", "no");
        console.log(`**** invitation already exists for either ${from} or ${to}`);
        return false;
      }
    }
    pendingInvitations.push({
      from: from.name,
      to: to.name
    });
    console.log(`**** forwarding invite from ${from.name} to ${to.name}`);
    idClientMap[to.id].emit("inviteFrom", from.name);
    return true;
  };

  handleInviteResponse = function(inviteeName, response) {
    var index, invitation, inviter, j, len;
    for (j = 0, len = pendingInvitations.length; j < len; j++) {
      invitation = pendingInvitations[j];
      if (invitation.to === inviteeName) {
        inviter = gameManager.getPlayerByName(invitation.from);
        if (inviter == null) {
          console.log(`*********** ERROR: Inviter ${invitation.from} not found in game manager`);
          index = pendingInvitations.indexOf(invitation);
          if (index >= 0) {
            pendingInvitations.splice(index, 1);
          }
          return false;
        }
        if (idClientMap[inviter.id] == null) {
          console.log(`*********** ERROR: Inviter ${invitation.from} is no longer connected`);
          index = pendingInvitations.indexOf(invitation);
          if (index >= 0) {
            pendingInvitations.splice(index, 1);
          }
          return false;
        }
        idClientMap[inviter.id].emit("inviteResponse", response);
        index = pendingInvitations.indexOf(invitation);
        if (index >= 0) {
          pendingInvitations.splice(index, 1);
        }
        return true;
      }
    }
    console.log(`*********** ERROR: Missing invitation from ${inviteeName}`);
    return false;
  };

}).call(this);
